#!/usr/bin/env python3
"""Create a tarball containing trained models and QFM artifacts for deployment."""

from __future__ import annotations

import argparse
import json
import os
import tarfile
import tempfile
from datetime import datetime
from pathlib import Path
from typing import Iterable, List, Optional

PROJECT_ROOT = Path(__file__).resolve().parents[1]


def _sanitize_profile(value: str | None) -> str:
    value = (value or "default").strip()
    sanitized = "".join(ch if ch.isalnum() or ch in {"-", "_"} else "-" for ch in value)
    sanitized = sanitized.lower()
    return sanitized or "default"


BOT_PROFILE = _sanitize_profile(os.getenv("BOT_PROFILE"))


def resolve_profile_path(relative_dir: str, *, ensure_exists: bool = False) -> Path:
    base = PROJECT_ROOT / relative_dir
    profiled = base / BOT_PROFILE

    if BOT_PROFILE == "default":
        target = profiled if profiled.exists() else base
    else:
        target = profiled

    if ensure_exists:
        target.mkdir(parents=True, exist_ok=True)
    return target


def _collect_model_files(models_dir: Path) -> List[str]:
    if not models_dir.exists():
        return []
    return sorted(p.name for p in models_dir.glob("*.pkl"))


def _load_qfm_summary(summary_path: Path) -> dict:
    if not summary_path.exists():
        return {}
    try:
        return json.loads(summary_path.read_text(encoding="utf-8"))
    except json.JSONDecodeError:
        return {}


def _build_manifest(models_dir: Path, artifacts_dir: Path, summary: dict) -> dict:
    rel_models = os.path.relpath(models_dir, PROJECT_ROOT) if models_dir.exists() else None
    rel_artifacts = os.path.relpath(artifacts_dir, PROJECT_ROOT) if artifacts_dir.exists() else None

    symbols = sorted(summary.get("symbols", {}).keys()) if isinstance(summary.get("symbols"), dict) else []

    return {
        "generated_at": datetime.utcnow().isoformat(timespec="seconds"),
        "bot_profile": BOT_PROFILE,
        "models_dir": rel_models,
        "artifacts_dir": rel_artifacts,
        "model_files": _collect_model_files(models_dir),
        "qfm_symbol_count": len(symbols),
        "qfm_symbols": symbols,
        "qfm_summary_path": os.path.relpath(artifacts_dir / "qfm_artifacts_summary.json", PROJECT_ROOT)
        if artifacts_dir.exists()
        else None,
    }


def _add_path(tar: tarfile.TarFile, path: Path) -> bool:
    if not path.exists():
        print(f"⚠️  Skipping missing path: {path}")
        return False
    arcname = path.relative_to(PROJECT_ROOT)
    tar.add(path, arcname=str(arcname))
    return True


def _validate_include_paths(paths: Iterable[str]) -> List[Path]:
    resolved: List[Path] = []
    for raw in paths:
        candidate = (PROJECT_ROOT / raw).resolve()
        try:
            candidate.relative_to(PROJECT_ROOT)
        except ValueError:
            raise ValueError(f"Include path must live inside the project: {raw}") from None
        resolved.append(candidate)
    return resolved


def create_bundle(output_dir: Path, filename: Optional[str], include: Iterable[str]) -> Path:
    models_dir = PROJECT_ROOT / "ultimate_models"
    artifacts_dir = resolve_profile_path("artifacts/qfm")
    summary = _load_qfm_summary(artifacts_dir / "qfm_artifacts_summary.json")
    manifest = _build_manifest(models_dir, artifacts_dir, summary)

    timestamp = datetime.utcnow().strftime("%Y%m%dT%H%M%S")
    bundle_name = filename or f"trading_bot_bundle_{BOT_PROFILE}_{timestamp}.tar.gz"
    bundle_path = output_dir / bundle_name
    output_dir.mkdir(parents=True, exist_ok=True)

    extras = _validate_include_paths(include)

    with tempfile.TemporaryDirectory() as staging:
        manifest_path = Path(staging) / "deploy_manifest.json"
        manifest_path.write_text(json.dumps(manifest, indent=2), encoding="utf-8")

        with tarfile.open(bundle_path, "w:gz") as tar:
            _add_path(tar, models_dir)
            _add_path(tar, artifacts_dir)
            for extra in extras:
                _add_path(tar, extra)
            tar.add(manifest_path, arcname="deploy_manifest.json")

    return bundle_path


def main() -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--output-dir",
        default="deployments",
        help="Relative directory for bundle output (default: deployments)",
    )
    parser.add_argument(
        "--filename",
        help="Optional custom filename for the bundle (default: autogenerated)",
    )
    parser.add_argument(
        "--include",
        action="append",
        default=[],
        help="Additional files or directories (relative to project root) to include in the bundle",
    )
    args = parser.parse_args()

    try:
        output_dir = (PROJECT_ROOT / args.output_dir).resolve()
        bundle_path = create_bundle(output_dir, args.filename, args.include)
    except Exception as exc:  # pylint: disable=broad-except
        print(f"❌ Bundle creation failed: {exc}")
        return 1

    rel_bundle = os.path.relpath(bundle_path, PROJECT_ROOT)
    print(f"✅ Deployment bundle created: {rel_bundle}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
