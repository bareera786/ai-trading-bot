#!/usr/bin/env python3
"""Lightweight gatekeeper for backtest health reports.

The script consumes the JSON payload produced by ``scripts/run_backtests.py`` and
flags any symbols that breach configured risk thresholds. It exits with
code ``0`` when all tracked assets stay within tolerance and ``1`` otherwise,
making it suitable for cron jobs or CI pipelines.
"""

from __future__ import annotations

import argparse
import json
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Tuple


@dataclass(frozen=True)
class Thresholds:
    min_total_return_pct: float = 0.0
    min_sharpe_ratio: float = 0.0
    max_drawdown_pct: float = 30.0


@dataclass(frozen=True)
class Breach:
    symbol: str
    reason: str
    observed: float
    expected: str


def load_report(path: Path) -> Dict:
    try:
        with path.open("r", encoding="utf-8") as handle:
            return json.load(handle)
    except FileNotFoundError as exc:
        raise SystemExit(f"Report not found: {path}") from exc
    except json.JSONDecodeError as exc:
        raise SystemExit(f"Report is not valid JSON: {path}\n{exc}") from exc


def evaluate_symbol(
    symbol: str, payload: Dict, thresholds: Thresholds
) -> Iterable[Breach]:
    summary = payload.get("symbol_summaries", {}).get(symbol)
    if summary is None:
        yield Breach(symbol, "missing from report", float("nan"), "present")
        return

    total_return = float(summary.get("total_return_pct", 0.0))
    sharpe = float(summary.get("sharpe_ratio", 0.0))
    drawdown = float(summary.get("max_drawdown_pct", 0.0))

    if total_return < thresholds.min_total_return_pct:
        yield Breach(
            symbol,
            "total return below floor",
            total_return,
            f">= {thresholds.min_total_return_pct}",
        )
    if sharpe < thresholds.min_sharpe_ratio:
        yield Breach(
            symbol,
            "sharpe ratio below floor",
            sharpe,
            f">= {thresholds.min_sharpe_ratio}",
        )
    if drawdown > thresholds.max_drawdown_pct:
        yield Breach(
            symbol,
            "drawdown exceeds cap",
            drawdown,
            f"<= {thresholds.max_drawdown_pct}",
        )


def format_breaches(breaches: Iterable[Breach]) -> Tuple[List[str], bool]:
    rows: List[str] = []
    had_breaches = False
    for breach in breaches:
        had_breaches = True
        rows.append(
            f"- {breach.symbol}: {breach.reason} (observed {breach.observed:.2f}, expected {breach.expected})"
        )
    return rows, had_breaches


def parse_args(argv: List[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Validate backtest health report thresholds."
    )
    parser.add_argument(
        "report",
        type=Path,
        nargs="?",
        default=Path("reports/backtest_top10.json"),
        help="Path to the JSON report generated by run_backtests.py",
    )
    parser.add_argument(
        "--symbols", nargs="*", help="Optional explicit list of symbols to validate."
    )
    parser.add_argument(
        "--min-total-return",
        type=float,
        default=Thresholds.min_total_return_pct,
        help="Minimum acceptable total return percentage.",
    )
    parser.add_argument(
        "--min-sharpe",
        type=float,
        default=Thresholds.min_sharpe_ratio,
        help="Minimum acceptable Sharpe ratio.",
    )
    parser.add_argument(
        "--max-drawdown",
        type=float,
        default=Thresholds.max_drawdown_pct,
        help="Maximum acceptable drawdown percentage.",
    )
    return parser.parse_args(argv)


def main(argv: List[str]) -> int:
    args = parse_args(argv)
    thresholds = Thresholds(
        min_total_return_pct=args.min_total_return,
        min_sharpe_ratio=args.min_sharpe,
        max_drawdown_pct=args.max_drawdown,
    )

    report = load_report(args.report)
    available_symbols = list(report.get("symbol_summaries", {}).keys())

    symbols = args.symbols or available_symbols
    missing_symbols = [sym for sym in symbols if sym not in available_symbols]
    if missing_symbols:
        for sym in missing_symbols:
            print(f"- {sym}: missing from report", file=sys.stderr)
        return 1

    breaches: List[Breach] = []
    for symbol in symbols:
        breaches.extend(evaluate_symbol(symbol, report, thresholds))

    rows, had_breaches = format_breaches(breaches)
    if not had_breaches:
        print(
            "All symbols met thresholds "
            f"(min return {thresholds.min_total_return_pct}%, "
            f"min Sharpe {thresholds.min_sharpe_ratio}, max drawdown {thresholds.max_drawdown_pct}%)."
        )
        return 0

    print("Health check failed for the following symbols:")
    for row in rows:
        print(row)
    return 1


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
