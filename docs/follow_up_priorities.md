# Post-Landing Follow-Up Priorities

This document captures the next high-impact improvements to pursue now that the login/landing flow has a professional subscription card. Each item is broken into scope, implementation outline, dependencies, and validation so we can execute end-to-end without ambiguity.

---

## 1. Public Marketing Blueprint & Hero Page
**Goal:** Provide a public-facing landing (no login required) that showcases the product, funnels visitors to Register, and re-uses the new hero + subscription card visuals.

**Key actions**
1. Create `app/routes/marketing.py` with a blueprint mounted at `/marketing` (and optionally `/`).
2. Add `app/templates/marketing/landing.html` that reuses `auth.css` plus additional testimonial/feature sections.
3. Gate `/` to either redirect anonymous visitors to the marketing page or login, controlled via `Config.SHOW_PUBLIC_LANDING`.
4. Add smoke tests (e.g., `tests/test_public_landing.py`) verifying the page loads without authentication.

**Dependencies:** Existing auth static assets; update `register_blueprints` to include the new blueprint.

**Validation:** `pytest tests/test_public_landing.py` plus manual check of `/marketing` without an authenticated session.

---

## 2. Dynamic Subscription Card Content
**Goal:** Keep the pricing/features shown on the landing page in sync with real subscription plans managed by admins.

**Key actions**
1. Extend `subscription_bp` with a read-only endpoint (`/api/subscriptions/plans`) that returns active plans and a highlighted default.
2. Update `auth/login.html` (and the future marketing template) to fetch plan data via `fetch` and render the first “hero” plan via a small JS snippet or Jinja context if SSR is preferred.
3. Allow admins to flag a plan as `is_featured` so marketing content highlights the correct tier.
4. Cache the response (simple in-memory cache or Flask-Caching) to avoid repeated DB hits.

**Dependencies:** `SubscriptionPlan` model (add `is_featured` boolean if missing).

**Validation:** Unit test around the new public endpoint + manual UI verification; ensure unauthenticated requests succeed.

---

## 3. Lead Capture & Onboarding Automation *(Status: ✅ Completed — dynamic API + admin view live)*
**Goal:** Convert visitors who are not ready to register into leads, then notify the ops team.

**Key actions**
1. Create `Lead` model with fields (name, email, company, status, created_at).
2. Add `/api/leads` endpoint (public POST, rate-limited via middleware) that stores leads and optionally pings a webhook/Slack.
3. Embed a short form in the marketing page (“Request White-Glove Onboarding”) wired to the endpoint.
4. Admin UI: add table under `app/routes/system_ops.py` or a dedicated blueprint to view/export leads.

**Dependencies:** DB migration for `Lead` table; optional integration secrets stored in `config/default`.

**Validation:** Unit tests for the POST endpoint + basic admin view, plus manual submission from the landing form. Implemented via `/api/leads` capture endpoint, `/api/leads/admin` export, `/admin/leads` UI, marketing form JS, `tests/test_lead_capture.py`, and `tests/test_admin_leads_view.py`.

---

## 4. Deployment & Monitoring Enhancements (Optional but Recommended)
- **Static asset pipeline:** evaluate `flask-assets` or Vite to bundle dashboard + auth/marketing CSS/JS with cache busting.
- **Uptime probes:** ✅ Covered by `tests/test_public_landing.py` and `scripts/uptime_probe.py` (see `docs/uptime_probes.md`).
- **Analytics hooks:** ✅ Completed via configurable Plausible-style snippet (set `ENABLE_MARKETING_ANALYTICS=1` + `MARKETING_ANALYTICS_SRC`, optional domain/api host) injected on `/marketing`, `/login`, and `/register`.

### 4a. Asset pipeline game plan
**Goal:** Consolidate dashboard/auth/marketing CSS+JS into a versioned bundle to prevent stale assets after deploys.

**Next actions**
1. Introduce a lightweight build step (prefer Vite for future React dashboards; fallback to Flask-Assets if we want Python-only) that emits `/app/static/dist/{app}.css|js` files with content hashes.
2. Add `npm` workspace in `app/frontend/` with `package.json` and `vite.config.ts` to compile the current static files and copy them into `app/static/dist/` during CI/deploy.
3. Extend Flask templates to reference `manifest.json` generated by Vite (or use `url_for('static', filename='dist/...')` with a helper that reads the manifest once and caches the hashed filenames).
4. Update deployment scripts (`deploy_to_vps_complete.sh`, systemd units) to run `npm install && npm run build` before syncing files, ensuring hashed assets are always published.

**Validation:** `npm run build`, confirm generated manifest and hashed assets load via Flask templates, then run the marketing/dashboard smoke tests to ensure templates load with the new asset paths.

---

## Execution Order
1. Marketing blueprint (fast path to a public landing).
2. Dynamic subscription data (ensures content fidelity).
3. Lead capture (turns traffic into pipeline).
4. Optional enhancements (assets/monitoring/analytics).

Each item above can be implemented independently but delivers more value when shipped sequentially because later steps reuse earlier scaffolding.